class DesignatorDescription(ABC):
    """
    :ivar resolve: The specialized_designators function to use for this designator, defaults to self.ground
    """

    def __init__(self, resolver: Optional[Callable] = None):
        """
        Create a Designator description.

        :param resolver: The grounding method used for the description. The grounding method creates a location instance that matches the description.
        :param ontology_concept_holders: A list of holders of ontology concepts that the designator is categorized as or associated with
        """
        if resolver is None:
            self.resolve = self.ground

    def ground(self) -> Any:
        """
        Should be overwritten with an actual grounding function which infers missing properties.
        """
        return self

class LocationDesignatorDescription(DesignatorDescription):
    """
    Parent class of location designator descriptions.
    """

    @dataclass
    class Location:
        """
        Resolved location that represents a specific point in the world which satisfies the constraints of the location
        designator description.
        """
        pose: Pose
        """
        The resolved pose of the location designator. Pose is inherited by all location designator.
        """

    def __init__(self, resolver=None):
        super().__init__(resolver)

    def ground(self) -> Location:
        """
        Find a location that satisfies all constrains.
        """
        raise NotImplementedError(f"{type(self)}.ground() is not implemented.")

class CostmapLocation(LocationDesignatorDescription):
    """
    Uses Costmaps to create locations for complex constrains
    """

    @dataclasses.dataclass
    class Location(LocationDesignatorDescription.Location):
        reachable_arms: List[str]
        """
        List of arms with which the pose can be reached, is only used when the 'rechable_for' parameter is used
        """

    def __init__(self, target: Union[Pose, ObjectDesignatorDescription.Object],
                 reachable_for: Optional[ObjectDesignatorDescription.Object] = None,
                 visible_for: Optional[ObjectDesignatorDescription.Object] = None,
                 reachable_arm: Optional[str] = None, resolver: Optional[Callable] = None):
        """
        Location designator that uses costmaps as base to calculate locations for complex constrains like reachable or
        visible. In case of reachable the resolved location contains a list of arms with which the location is reachable.

        :param target: Location for which visibility or reachability should be calculated
        :param reachable_for: Object for which the reachability should be calculated, usually a robot
        :param visible_for: Object for which the visibility should be calculated, usually a robot
        :param reachable_arm: An optional arm with which the target should be reached
        :param resolver: An alternative specialized_designators that returns a resolved location for the given input of this description
        """
        super().__init__(resolver)
        self.target: Union[Pose, ObjectDesignatorDescription.Object] = target
        self.reachable_for: ObjectDesignatorDescription.Object = reachable_for
        self.visible_for: ObjectDesignatorDescription.Object = visible_for
        self.reachable_arm: Optional[str] = reachable_arm

    def ground(self) -> Location:
        """
        Default specialized_designators which returns the first result from the iterator of this instance.

        :return: A resolved location
        """
        pass

class SemanticCostmapLocation(LocationDesignatorDescription):
    """
    Locations over semantic entities, like a table surface
    """

    @dataclasses.dataclass
    class Location(LocationDesignatorDescription.Location):
        pass

    def __init__(self, urdf_link_name, part_of, for_object=None, resolver=None):
        """
        Creates a distribution over a urdf link to sample poses which are on this link. Can be used, for example, to find
        poses that are on a table. Optionally an object can be given for which poses should be calculated, in that case
        the poses are calculated such that the bottom of the object is on the link.

        :param urdf_link_name: Name of the urdf link for which a distribution should be calculated
        :param part_of: Object of which the urdf link is a part
        :param for_object: Optional object that should be placed at the found location
        :param resolver: An alternative specialized_designators that creates a resolved location for the input parameter of this description
        """
        super().__init__(resolver)
        self.urdf_link_name: str = urdf_link_name
        self.part_of: ObjectDesignatorDescription.Object = part_of
        self.for_object: Optional[ObjectDesignatorDescription.Object] = for_object

    def ground(self) -> Location:
        """
        Default specialized_designators which returns the first element of the iterator of this instance.

        :return: A resolved location
        """
        pass